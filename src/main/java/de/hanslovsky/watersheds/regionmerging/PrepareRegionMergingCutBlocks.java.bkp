package de.hanslovsky.watersheds.regionmerging;

import java.io.Serializable;
import java.util.Arrays;

import org.apache.spark.api.java.JavaPairRDD;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.api.java.function.PairFunction;
import org.apache.spark.broadcast.Broadcast;

import de.hanslovsky.watersheds.DisjointSetsHashMap;
import de.hanslovsky.watersheds.HashableLongArray;
import de.hanslovsky.watersheds.graph.Edge;
import de.hanslovsky.watersheds.graph.EdgeMerger;
import de.hanslovsky.watersheds.graph.Function;
import de.hanslovsky.watersheds.graph.IdService;
import de.hanslovsky.watersheds.graph.MergeBloc;
import de.hanslovsky.watersheds.graph.MergeBloc.In;
import de.hanslovsky.watersheds.graph.UndirectedGraph;
import de.hanslovsky.watersheds.regionmerging.PrepareRegionMergingCutBlocks.GetInternalEdgesAndSplits.Output;
import gnu.trove.iterator.TLongIterator;
import gnu.trove.iterator.TLongLongIterator;
import gnu.trove.list.array.TDoubleArrayList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.hash.TLongIntHashMap;
import gnu.trove.map.hash.TLongLongHashMap;
import gnu.trove.map.hash.TLongObjectHashMap;
import gnu.trove.set.hash.TLongHashSet;
import net.imglib2.Cursor;
import net.imglib2.RandomAccess;
import net.imglib2.RandomAccessibleInterval;
import net.imglib2.algorithm.morphology.watershed.affinity.CompositeFactory;
import net.imglib2.img.array.ArrayImg;
import net.imglib2.img.array.ArrayImgs;
import net.imglib2.img.basictypeaccess.array.LongArray;
import net.imglib2.type.numeric.RealType;
import net.imglib2.type.numeric.integer.LongType;
import net.imglib2.type.numeric.real.FloatType;
import net.imglib2.util.IntervalIndexer;
import net.imglib2.view.IntervalView;
import net.imglib2.view.Views;
import net.imglib2.view.composite.CompositeIntervalView;
import net.imglib2.view.composite.RealComposite;
import scala.Tuple2;
import scala.Tuple3;
import scala.Tuple5;

public class PrepareRegionMergingCutBlocks
{

	public static void run(
			final JavaSparkContext sc,
			final JavaPairRDD< HashableLongArray, Tuple3< long[], float[], TLongLongHashMap > > blocksWithLabelsAffinitiesAndCounts,
			final Broadcast< long[] > dim,
			final Broadcast< long[] > blockDim,
			final EdgeMerger edgeMerger,
			final Function func,
			final EdgeCheck edgeCheck,
			final IdService idService )
	{
		final JavaPairRDD< HashableLongArray, Output > intraBlockEdges =
				blocksWithLabelsAffinitiesAndCounts.mapToPair( new GetInternalEdgesAndSplits<>( blockDim, edgeMerger, func, edgeCheck, idService ) );
	}

	public static class SplitData
	{
		public final TDoubleArrayList edges;

		public final TLongLongHashMap counts;

		public final TLongObjectHashMap< TLongHashSet > newBorderNodes;

		public final TLongObjectHashMap< TLongObjectHashMap< TLongHashSet > > borderNodesToOutsideNodesByBlock;

		public final TLongLongHashMap borderNodeBlockAssignment;

		public SplitData(
				final TDoubleArrayList edges,
				final TLongLongHashMap counts,
				final TLongObjectHashMap< TLongHashSet > newBorderNodes,
				final TLongObjectHashMap< TLongObjectHashMap< TLongHashSet > > borderNodesToOutsideNodesByBlock,
				final TLongLongHashMap borderNodeBlockAssignment )
		{
			super();
			this.edges = edges;
			this.counts = counts;
			this.newBorderNodes = newBorderNodes;
			this.borderNodesToOutsideNodesByBlock = borderNodesToOutsideNodesByBlock;
			this.borderNodeBlockAssignment = borderNodeBlockAssignment;
		}

	}

	public static class GetInternalEdgesAndSplits< K > implements
	PairFunction< Tuple2< K, Tuple3< long[], float[], TLongLongHashMap > >, K, GetInternalEdgesAndSplits.Output >
	{

		public static class Output
		{

			public final long[] labels;

			public final float[] affinities;

			public final TLongLongHashMap counts;

			public final UndirectedGraph g;

			public final TLongLongHashMap nodeBlockAssignment;

			public Output( final long[] labels, final float[] affinities, final TLongLongHashMap counts, final UndirectedGraph g, final TLongLongHashMap nodeBlockAssignment )
			{
				super();
				this.labels = labels;
				this.affinities = affinities;
				this.counts = counts;
				this.g = g;
				this.nodeBlockAssignment = nodeBlockAssignment;
			}


		}

		private final Broadcast< long[] > blockDim;

		private final EdgeMerger edgeMerger;

		private final Function func;

		private final EdgeCheck edgeCheck;

		private final IdService idService;

		public GetInternalEdgesAndSplits(
				final Broadcast< long[] > blockDim,
				final EdgeMerger edgeMerger,
				final Function func,
				final EdgeCheck edgeCheck,
				final IdService idService )
		{
			super();
			this.blockDim = blockDim;
			this.edgeMerger = edgeMerger;
			this.func = func;
			this.edgeCheck = edgeCheck;
			this.idService = idService;
		}

		@Override
		public Tuple2< K, Output > call( final Tuple2< K, Tuple3< long[], float[], TLongLongHashMap > > t ) throws Exception
		{
			final long[] blockDim = this.blockDim.getValue();
			final long[] extendedBlockDim = padDimensions( blockDim, 1 );
			final long[] extendedAffinitiesBlockDim = getAffinityDims( extendedBlockDim );
			final long[] offset = new long[ blockDim.length ];
			Arrays.fill( offset, 1 );

			final ArrayImg< LongType, LongArray > labels = ArrayImgs.longs( t._2()._1(), extendedBlockDim );
			final CompositeIntervalView< FloatType, RealComposite< FloatType > > affinities =
					Views.collapseReal( ArrayImgs.floats( t._2()._2(), extendedAffinitiesBlockDim ) );

			final IntervalView< LongType > innerLabels = Views.offsetInterval( labels, offset, blockDim );
			final IntervalView< RealComposite< FloatType > > innerAffinities = Views.offsetInterval( affinities, offset, blockDim );

			final TDoubleArrayList edges = new TDoubleArrayList();
			final TDoubleArrayList edgesDummy = new TDoubleArrayList();
			final Edge e = new Edge( edges );
			final Edge dummy = new Edge( edgesDummy );
			dummy.add( Double.NaN, 0.0, 0, 0, 1 );
			final TLongLongHashMap counts = new TLongLongHashMap();// t._2()._3();
			final UndirectedGraph g = new UndirectedGraph( edges, edgeMerger );
			final TLongObjectHashMap< TLongIntHashMap > nodeEdgeMap = g.nodeEdgeMap();

			addEdges( innerLabels, innerAffinities, blockDim, g, nodeEdgeMap, e, dummy, edgeMerger );
			final int nIntraBlockEdges = e.size();

			final TLongLongHashMap parents = new TLongLongHashMap();
			final DisjointSetsHashMap dj = new DisjointSetsHashMap( parents, new TLongLongHashMap(), 0 );
			final TIntArrayList splitEdges = new TIntArrayList();
			for ( int i = 0; i < nIntraBlockEdges; ++i )
			{
				e.setIndex( i );
				e.weight( func.weight( e.affinity(), counts.get( e.from() ), counts.get( e.to() ) ) );
				if ( edgeCheck.isGoodEdge( e ) )
					dj.join( dj.findRoot( e.from() ), dj.findRoot( e.to() ) );
				else
					splitEdges.add( i );
			}

			final TLongLongHashMap nodeBlockAssignment = assignNodesToBlocks( idService, dj, parents, new TLongLongHashMap() );// new
			final Output output = new Output( t._2()._1(), t._2()._2(), t._2()._3(), g, nodeBlockAssignment );


			return new Tuple2<>( t._1, output );
		}

	}

	public static class BuildBlockedGraph implements
	PairFunction< Tuple2< HashableLongArray, Tuple3< long[], float[], TLongLongHashMap > >, Long, MergeBloc.In >
	{

		/**
		 *
		 */
		private static final long serialVersionUID = -2176070570757172192L;

		private final long[] dim;

		private final long[] blockDim;

		private final EdgeMerger edgeMerger;

		private final Function func;

		private final EdgeCheck edgeCheck;

		private final IdService idService;

		public BuildBlockedGraph( final long[] dim, final long[] blockDim, final EdgeMerger edgeMerger, final Function func, final EdgeCheck edgeCheck, final IdService idService )
		{
			super();
			this.dim = dim;
			this.blockDim = blockDim;
			this.edgeMerger = edgeMerger;
			this.func = func;
			this.edgeCheck = edgeCheck;
			this.idService = idService;
		}

		@Override
		public Tuple2< Long, In > call( final Tuple2< HashableLongArray, Tuple3< long[], float[], TLongLongHashMap > > t ) throws Exception
		{
			final long[] pos = t._1().getData();

			final long[] dim = this.dim;
			final long[] blockDim = this.blockDim;
			final long[] numBlocksByDimension = new long[ blockDim.length ];
			final long[] extendedBlockDim = new long[ blockDim.length ];
			final long[] extendedAffinitiesBlockDim = new long[ blockDim.length + 1 ];

			System.arraycopy( blockDim, 0, extendedAffinitiesBlockDim, 0, blockDim.length );
			extendedAffinitiesBlockDim[ blockDim.length ] = blockDim.length;
			for ( int d = 0; d < blockDim.length; ++d )
			{
				final long v = blockDim[ d ] + 2;
				extendedBlockDim[ d ] = v;
				extendedAffinitiesBlockDim[ d ] = v;
				numBlocksByDimension[ d ] = ( long ) Math.ceil( dim[ d ] * 1.0 / blockDim[ d ] );
			}
			final long[] offset = new long[ blockDim.length ];
			Arrays.fill( offset, 1 );
			final long[] blockIndices = new long[ pos.length ];
			for ( int d = 0; d < pos.length; ++d )
				blockIndices[ d ] = pos[ d ] / blockDim[ d ];
//					new long[] { t._1()._1() / blockDim[ 1 ], t._1()._2() / blockDim[ 1 ], t._1()._3() / blockDim[ 2 ] };
			final long id = IntervalIndexer.positionToIndex( blockIndices, numBlocksByDimension );

			final CompositeFactory< FloatType, RealComposite< FloatType > > compositeFactory = ( size ) -> Views.collapseReal( ArrayImgs.floats( 1, size ) ).randomAccess().get();
			final RealComposite< FloatType > extension = compositeFactory.create( blockDim.length );
			for ( int d = 0; d < blockDim.length; ++d )
				extension.get( d ).set( Float.NaN );

			final ArrayImg< LongType, LongArray > labels = ArrayImgs.longs( t._2()._1(), extendedBlockDim );
			final CompositeIntervalView< FloatType, RealComposite< FloatType > > affinities =
					Views.collapseReal( ArrayImgs.floats( t._2()._2(), extendedAffinitiesBlockDim ) );

			final IntervalView< LongType > innerLabels = Views.offsetInterval( labels, offset, blockDim );
			final IntervalView< RealComposite< FloatType > > innerAffinities = Views.offsetInterval( affinities, offset, blockDim );


			final TDoubleArrayList edges = new TDoubleArrayList();
			final TDoubleArrayList edgesDummy = new TDoubleArrayList();
			final Edge e = new Edge( edges );
			final Edge dummy = new Edge( edgesDummy );
			dummy.add( Double.NaN, 0.0, 0, 0, 1 );
			final TLongLongHashMap counts = new TLongLongHashMap();// t._2()._3();
			final TLongObjectHashMap< TLongHashSet > borderNodes = new TLongObjectHashMap< TLongHashSet >();
			final UndirectedGraph g = new UndirectedGraph( edges, edgeMerger );
			final TLongObjectHashMap< TLongIntHashMap > nodeEdgeMap = g.nodeEdgeMap();


			addEdges( innerLabels, innerAffinities, blockDim, g, nodeEdgeMap, e, dummy, edgeMerger );

			final int nIntraBlockEdges = e.size();

			final TLongLongHashMap parents = new TLongLongHashMap();
			final DisjointSetsHashMap dj = new DisjointSetsHashMap( parents, new TLongLongHashMap(), 0 );
			final TIntArrayList splitEdges = new TIntArrayList();
			for ( int i = 0; i < nIntraBlockEdges; ++i )
			{
				e.setIndex( i );
				e.weight( func.weight( e.affinity(), counts.get( e.from() ), counts.get( e.to() ) ) );
				if ( edgeCheck.isGoodEdge( e ) )
					dj.join( dj.findRoot( e.from() ), dj.findRoot( e.to() ) );
				else
					splitEdges.add( i );
			}

			final TLongObjectHashMap< TLongHashSet > newBorderNodes = new TLongObjectHashMap<>();
			for ( final TLongLongIterator it = parents.iterator(); it.hasNext(); )
			{
				it.advance();
				final long r = dj.findRoot( it.key() );
				if ( !newBorderNodes.contains( r ) )
					newBorderNodes.put( r, new TLongHashSet() );
			}

			//
			for ( int i = 0; i < splitEdges.size(); ++i )
			{
				e.setIndex( splitEdges.get( i ) );
				final long from = e.from();
				final long to = e.to();
				newBorderNodes.get( dj.findRoot( from ) ).add( from );
				newBorderNodes.get( dj.findRoot( to ) ).add( to );
			}


			final int numberOfNewIndices = dj.setCount();
			final long startIndex = idService.requestIds( numberOfNewIndices );
			final long stopIndex = numberOfNewIndices + startIndex;
			final TLongLongHashMap blockIdMapping = reIndexNewBorderNodes( newBorderNodes, startIndex, stopIndex );
			final TLongLongHashMap nodeBlockAssignment = new TLongLongHashMap();
			for ( final TLongLongIterator it = parents.iterator(); it.hasNext(); )
			{
				it.advance();
				nodeBlockAssignment.put( it.key(), blockIdMapping.get( it.value() ) );
			}

			final TLongObjectHashMap< TLongObjectHashMap< TLongHashSet > > borderNodesToOutsideNodesByBlock = new TLongObjectHashMap<>();
			for ( final TLongIterator it = blockIdMapping.valueCollection().iterator(); it.hasNext(); )
				borderNodesToOutsideNodesByBlock.put( it.next(), new TLongObjectHashMap<>() );
			final TLongLongHashMap borderNodeBlockAssignment = new TLongLongHashMap();

			for ( int d = 0; d < blockDim.length; ++d )
			{
				blockIndices[ d ] -= 1;
				if ( blockIndices[ d ] >= 0 )
				{
					final long outer = 0;
					final long inner = outer + 1;
					final long neighborId = IntervalIndexer.positionToIndex( blockIndices, numBlocksByDimension );
					addEdgesFromNeighborBlocks(
							labels, affinities, d, inner, outer, g, nodeEdgeMap, e, dummy,
							edgeMerger, neighborId, borderNodesToOutsideNodesByBlock, borderNodeBlockAssignment, nodeBlockAssignment, blockDim );

				}
				blockIndices[ d ] += 2;
				if ( blockIndices[ d ] < numBlocksByDimension[ d ] )
				{
					final long inner = labels.max( d ) - 1;
					final long outer = inner + 1;
					final long neighborId = IntervalIndexer.positionToIndex( blockIndices, numBlocksByDimension );
					addEdgesFromNeighborBlocks(
							labels, affinities, d, inner, outer, g, nodeEdgeMap, e, dummy,
							edgeMerger, neighborId, borderNodesToOutsideNodesByBlock, borderNodeBlockAssignment, nodeBlockAssignment, blockDim );
				}
				blockIndices[ d ] -= 1;
			}

			for ( final TLongLongIterator it = t._2()._3().iterator(); it.hasNext(); )
			{
				it.advance();
				final long k = it.key();
				if ( nodeEdgeMap.contains( k ) )
					counts.put( k, it.value() );
			}

			final Tuple5< TDoubleArrayList, TLongLongHashMap, TLongObjectHashMap< TLongHashSet >, TLongObjectHashMap< TLongObjectHashMap< TLongHashSet > >, TLongLongHashMap > data =
					new Tuple5<>( edges, counts, newBorderNodes, borderNodesToOutsideNodesByBlock, borderNodeBlockAssignment );
			final Tuple2< Long, Tuple5< TDoubleArrayList, TLongLongHashMap, TLongObjectHashMap< TLongHashSet >, TLongObjectHashMap< TLongObjectHashMap< TLongHashSet > >, TLongLongHashMap > > op = new Tuple2<>( id, data );

			return new Tuple2<>( id, new MergeBloc.In( edges, counts, borderNodes ) );
		}

	}

	private static TLongLongHashMap reIndexNewBorderNodes( final TLongObjectHashMap< TLongHashSet > newBorderNodes, final long startIndex, final long stopIndex )
	{
		assert stopIndex - startIndex == newBorderNodes.size();
		final TLongLongHashMap blockIdMapping = new TLongLongHashMap();

		long index = startIndex;
		for ( final long k : newBorderNodes.keys() )
		{
			blockIdMapping.put( k, index );
			newBorderNodes.put( index, newBorderNodes.remove( k ) );
			++index;
		}

		newBorderNodes.compact();

		return blockIdMapping;
	}

	private static < T extends RealType< T > > void addEdges(
			final IntervalView< LongType > labels,
			final IntervalView< RealComposite< T > > affinities,
			final long[] blockDim,
			final UndirectedGraph g,
			final TLongObjectHashMap< TLongIntHashMap > nodeEdgeMap,
			final Edge e,
			final Edge dummy,
			final EdgeMerger edgeMerger )
	{
		final RandomAccess< LongType > labelsAccess = labels.randomAccess();
		final Cursor< RealComposite< T > > affinitiesCursor = affinities.cursor();
		while ( affinitiesCursor.hasNext() )
		{
			final RealComposite< T > affinity = affinitiesCursor.next();
			labelsAccess.setPosition( affinitiesCursor );
			final long label = labelsAccess.get().get();
			for ( int d = 0; d < blockDim.length; ++d )
				if ( labelsAccess.getLongPosition( d ) < blockDim[ d ] - 1 )
				{
					final double aff = affinity.get( d ).getRealDouble();
					if ( !Double.isNaN( aff ) )
					{
						labelsAccess.fwd( d );
						final long otherLabel = labelsAccess.get().get();
						if ( otherLabel != label )
							addEdge( label, otherLabel, aff, g, nodeEdgeMap, e, dummy, edgeMerger );
						labelsAccess.bck( d );
					}
				}
		}
	}

	private static void addEdge(
			final long label,
			final long otherLabel,
			final double aff,
			final UndirectedGraph g,
			final TLongObjectHashMap< TLongIntHashMap > nodeEdgeMap,
			final Edge e,
			final Edge dummy,
			final EdgeMerger edgeMerger )
	{
		if ( !nodeEdgeMap.contains( label ) )
			g.addNode( label );
		if ( !nodeEdgeMap.contains( otherLabel ) )
			g.addNode( otherLabel );
		final TLongIntHashMap localEdges = nodeEdgeMap.get( label );
		if ( !localEdges.contains( otherLabel ) )
			g.addEdge( Double.NaN, aff, label, otherLabel, 1 );
		else
		{
			e.setIndex( localEdges.get( otherLabel ) );
			dummy.affinity( aff );
			dummy.from( label );
			dummy.to( otherLabel );
			edgeMerger.merge( dummy, e );
		}
	}

	private static < T extends RealType< T > > void addEdgesFromNeighborBlocks(
			final RandomAccessibleInterval< LongType > labels,
			final RandomAccessibleInterval< RealComposite< T > > affinities,
			final int d,
			final long innerIndex,
			final long outerIndex,
			final UndirectedGraph g,
			final TLongObjectHashMap< TLongIntHashMap > nodeEdgeMap,
			final Edge e,
			final Edge dummy,
			final EdgeMerger edgeMerger,
			final long neighborId,
			final TLongObjectHashMap< TLongObjectHashMap< TLongHashSet > > borderNodesToOutsideNodesByBlock,
			final TLongLongHashMap borderNodeBlockAssignment,
			final TLongLongHashMap nodeBlockAssignment,
			final long[] blockDim )
	{
		final long[] croppedDim = new long[ labels.numDimensions() - 1 ];
		final long[] offset = new long[ croppedDim.length ];
		Arrays.fill( offset, 1l );
		for ( int i = 0, k = 0; i < blockDim.length; ++i )
		{
			if ( i == d )
				continue;
			croppedDim[ k ] = blockDim[ i ];
			++k;
		}
		final IntervalView< LongType > labelsInner = Views.hyperSlice( labels, d, innerIndex );
		final IntervalView< LongType > labelsOuter = Views.hyperSlice( labels, d, outerIndex );
		final IntervalView< RealComposite< T > > affinitiesSlice = Views.hyperSlice( affinities, d, Math.min( innerIndex, outerIndex ) );
		final Cursor< LongType > iC = Views.offsetInterval( labelsInner, offset, croppedDim ).cursor();
		final Cursor< LongType > oC = Views.offsetInterval( labelsOuter, offset, croppedDim ).cursor();
		final Cursor< RealComposite< T > > aC = Views.offsetInterval( affinitiesSlice, offset, croppedDim ).cursor();
		while( iC.hasNext() ) {
			final long label = iC.next().get();
			final long otherLabel = oC.next().get();
			final RealComposite< T > affs = aC.next();
			if ( label != otherLabel )
			{
				final double aff = affs.get( d ).getRealDouble();
				if ( !Double.isNaN( aff ) )
				{
					final long block = nodeBlockAssignment.get( label );
					borderNodeBlockAssignment.put( label, block );
					final TLongObjectHashMap< TLongHashSet > nodeToOutsideNode = borderNodesToOutsideNodesByBlock.get( block );
					if ( !nodeToOutsideNode.contains( label ) )
						nodeToOutsideNode.put( label, new TLongHashSet() );
					nodeToOutsideNode.get( label ).add( neighborId );
					addEdge( label, otherLabel, aff, g, nodeEdgeMap, e, dummy, edgeMerger );
				}
			}
		}
	}

	public static class CountOverSquaredSize implements Function, Serializable
	{
		/**
		 *
		 */
		private static final long serialVersionUID = -2382379605891324313L;

		@Override
		public double weight( final double a, final long c1, final long c2 )
		{
			return Math.min( c1, c2 ) / ( a * a );
		}

	}

	public static long[] getAffinityDims( final long[] input )
	{
		return getAffinityDims( input, new long[ input.length ] );
	}

	public static long[] getAffinityDims( final long[] input, final long[] output )
	{
		System.arraycopy( input, 0, output, 0, input.length );
		output[ input.length ] = input.length;
		return output;
	}

	public static long[] padDimensions( final long[] input, final long pad )
	{
		return padDimensions( input, new long[ input.length ], pad );
	}

	public static long[] padDimensions( final long[] input, final long[] output, final long pad )
	{
		for ( int d = 0; d < input.length; ++d )
			output[ d ] += 2 * d;
		return input;
	}

	public static TLongLongHashMap assignNodesToBlocks(
			final IdService idService,
			final DisjointSetsHashMap dj,
			final TLongLongHashMap parents,
			final TLongLongHashMap rootToGlobalIdMapping )
	{
		final TLongLongHashMap assignment = new TLongLongHashMap();

		long id = idService.requestIds( dj.setCount() );

		for ( final TLongLongIterator it = parents.iterator(); it.hasNext(); )
		{
			it.advance();
			final long r = it.value();
			final long block;
			if ( !rootToGlobalIdMapping.contains( r ) )
			{
				block = id++;
				rootToGlobalIdMapping.put( r, block );
			}
			else
				block = rootToGlobalIdMapping.get( r );
			assignment.put( it.key(), block );
		}

		return assignment;
	}


}
